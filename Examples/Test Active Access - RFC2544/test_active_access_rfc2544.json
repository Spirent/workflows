{
  "updateTime": 1636041876296,
  "name": "test_active_access_rfc2544",
  "description": "Denim - COX Active Testing RFC2544",
  "version": 1,
  "tasks": [
    {
      "name": "check_eswitch_enabled_decision_task",
      "taskReferenceName": "check_eswitch_enabled_decision",
      "inputParameters": {
        "enabled": "${workflow.input.topology.neFrom.enabled}"
      },
      "type": "DECISION",
      "caseValueParam": "enabled",
      "decisionCases": {
        "false": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"'${workflow.input.topology.neFrom.name}' Ethernet Switch is disabled\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "check_nid_enabled_decision_task",
      "taskReferenceName": "check_nid_enabled_decision",
      "inputParameters": {
        "enabled": "${workflow.input.topology.neTo.enabled}"
      },
      "type": "DECISION",
      "caseValueParam": "enabled",
      "decisionCases": {
        "false": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"'${workflow.input.topology.neTo.name}' NID is disabled\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "get_service_vta_lambda",
      "taskReferenceName": "get_service_vta",
      "inputParameters": {
        "neFrom": "${workflow.input.topology.neFrom}",
        "scriptExpression": "var vta;\nif ($.neFrom.vta != null) {\n  vta = $.neFrom.vta;\n}\nif ($.neFrom.wboxes != null && $.neFrom.wboxes[\"0\"] != null && $.neFrom.wboxes[\"0\"].vtas != null && $.neFrom.wboxes[\"0\"].vtas[\"0\"] != null) {\n  vta = $.neFrom.wboxes[\"0\"].vtas[\"0\"];\n}\nif (vta != null && (!vta.name || !vta.name.length)) {\n  vta.name = \"unknown_vta_name\";\n}\nreturn vta;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "check_ne_lambda_task",
      "taskReferenceName": "check_ne",
      "inputParameters": {
        "neFromVendor": "${workflow.input.topology.neFrom.vendor}",
        "neFromTypeCode": "${workflow.input.topology.neFrom.typeCode}",
        "neFromModel": "${workflow.input.topology.neFrom.model}",
        "neToTypeCode": "${workflow.input.topology.neTo.typeCode}",
        "neToVendor": "${workflow.input.topology.neTo.vendor}",
        "vta": "${get_service_vta.output.result}",
        "scriptExpression": "if ($.neFromTypeCode !== 39) {\n    return {\n        output: JSON.stringify({errorMessage: \"Incorrect NE type. 'From NE' must be Ethernet Switch\"}),\n        status: 'CHECK_ERROR'\n    }\n} else if ($.neToTypeCode !== 46) {\n    return {output: JSON.stringify({errorMessage: \"Incorrect NE type. 'To NE' must be NTE\"}), status: 'CHECK_ERROR'}\n} else if (Array.prototype.indexOf.apply(['NOKIA', 'ALCATEL'], [$.neToVendor]) < 0) {\n    return {\n        output: JSON.stringify({errorMessage: $.neToVendor + ' NID vendor is not supported. Supported vendors: ALCATEL, NOKIA'}),\n        status: 'CHECK_ERROR'\n    }\n} else if (Array.prototype.indexOf.apply(['NOKIA', 'ALCATEL'], [$.neFromVendor]) < 0) {\n    return {\n        output: JSON.stringify({errorMessage: $.neFromVendor + ' E-Switch vendor is not supported. Supported vendors: NOKIA, ALCATEL'}),\n        status: 'CHECK_ERROR'\n    }\n} else if ($.neFromVendor === 'NOKIA' && $.neFromModel !== '7450' && $.neFromModel !== '7750' && $.neFromModel !== '7950') {\n    return {\n        output: JSON.stringify({errorMessage: $.neFromModel + ' E-Switch model is not supported.'}),\n        status: 'CHECK_ERROR'\n    }\n} else if (!$.vta) {\n    return {\n        output: JSON.stringify({errorMessage: 'E-Switch doesn\\'t have rfc2544 VTA.'}),\n        status: 'CHECK_ERROR'\n    }\n} else {\n    return {status: 'OK'}\n}"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "check_ne_decision_task",
      "taskReferenceName": "check_ne_decision",
      "inputParameters": {
        "status": "${check_ne.output.result.status}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "CHECK_ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${check_ne.output.result}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "find_test_group_by_name",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-testcontroller:3030/api/v1/vtas?name=${get_service_vta.output.result.name}",
            "method": "GET",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}"
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "check_if_test_group_by_name_found_decision",
      "taskReferenceName": "check_if_test_group_by_name_found",
      "inputParameters": {
        "test_groups": "${find_test_group_by_name.output.response.body}"
      },
      "type": "DECISION",
      "caseExpression": "$.test_groups.length",
      "decisionCases": {
        "0": [
          {
            "name": "get_vta_address_lambda",
            "taskReferenceName": "get_vta_address",
            "inputParameters": {
              "vta": "${get_service_vta.output.result}",
              "scriptExpression": "var ip = \"\", mac = \"\";\nif ($.vta.addr && $.vta.addr.match(/\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b/)) {\n    ip = $.vta.addr;\n}\nif ($.vta.macAddr) {\n    mac = $.vta.macAddr;\n} else if ($.vta.addr && $.vta.addr.match(/^([0-9a-f]{2}:?){6}$/i)) {\n    mac = $.vta.addr;\n}\nreturn {\n    ip: ip,\n    mac: mac.replace(/:/g, '').replace(/(.{2})\\B/gi, '$1:')\n}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "check_if_vta_address_specified_decision",
            "taskReferenceName": "check_if_vta_address_specified",
            "inputParameters": {
              "addresses": "${get_vta_address.output.result}"
            },
            "type": "DECISION",
            "caseExpression": "!!($.addresses.ip || $.addresses.mac)",
            "decisionCases": {
              "false": [
                {
                  "name": "fail_test_no_vta",
                  "taskReferenceName": "fail_test",
                  "inputParameters": {
                    "terminationStatus": "FAILED",
                    "workflowOutput": "{\"errorMessage\": \"VTA not found in Test Controller\"}"
                  },
                  "type": "TERMINATE",
                  "decisionCases": {},
                  "defaultCase": [],
                  "forkTasks": [],
                  "startDelay": 0,
                  "joinOn": [],
                  "optional": false,
                  "defaultExclusiveJoinTask": [],
                  "asyncComplete": false,
                  "loopOver": []
                }
              ]
            },
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "generic_task_no_retry",
            "taskReferenceName": "find_test_group_by_address",
            "inputParameters": {
              "http_request": {
                "uri": "http://conductor-helper:8085/http",
                "method": "POST",
                "readTimeOut": 30000,
                "connectionTimeOut": 30000,
                "body": {
                  "uri": "http://us-testcontroller:3030/api/v1/vtas?address=${get_vta_address.output.result.ip}&macAddress=${get_vta_address.output.result.mac}",
                  "method": "GET",
                  "accessToken": "${workflow.input.security.access_token}",
                  "refreshToken": "${workflow.input.security.refresh_token}"
                }
              }
            },
            "type": "HTTP",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "check_if_test_group_by_address_found_decision",
            "taskReferenceName": "check_if_test_group_by_address_found",
            "inputParameters": {
              "test_groups": "${find_test_group_by_address.output.response.body}"
            },
            "type": "DECISION",
            "caseExpression": "$.test_groups.length",
            "decisionCases": {
              "0": [
                {
                  "name": "generic_task_no_retry",
                  "taskReferenceName": "find_test_group_by_base_url",
                  "inputParameters": {
                    "http_request": {
                      "uri": "http://conductor-helper:8085/http",
                      "method": "POST",
                      "readTimeOut": 30000,
                      "connectionTimeOut": 30000,
                      "body": {
                        "uri": "http://us-testcontroller:3030/api/v1/vtas?baseUrl=*/${get_service_vta.output.result.addr}:*",
                        "method": "GET",
                        "accessToken": "${workflow.input.security.access_token}",
                        "refreshToken": "${workflow.input.security.refresh_token}"
                      }
                    }
                  },
                  "type": "HTTP",
                  "decisionCases": {},
                  "defaultCase": [],
                  "forkTasks": [],
                  "startDelay": 0,
                  "joinOn": [],
                  "optional": false,
                  "defaultExclusiveJoinTask": [],
                  "asyncComplete": false,
                  "loopOver": []
                },
                {
                  "name": "check_if_test_group_by_base_url_found_decision",
                  "taskReferenceName": "check_if_test_group_by_base_url_found",
                  "inputParameters": {
                    "test_groups": "${find_test_group_by_base_url.output.response.body}"
                  },
                  "type": "DECISION",
                  "caseExpression": "$.test_groups.length",
                  "decisionCases": {
                    "0": [
                      {
                        "name": "fail_test_no_vta",
                        "taskReferenceName": "fail_test",
                        "inputParameters": {
                          "terminationStatus": "FAILED",
                          "workflowOutput": "{\"errorMessage\": \"VTA not found in Test Controller\"}"
                        },
                        "type": "TERMINATE",
                        "decisionCases": {},
                        "defaultCase": [],
                        "forkTasks": [],
                        "startDelay": 0,
                        "joinOn": [],
                        "optional": false,
                        "defaultExclusiveJoinTask": [],
                        "asyncComplete": false,
                        "loopOver": []
                      }
                    ]
                  },
                  "defaultCase": [
                    {
                      "name": "get_test_group_by_baseUrl_lambda",
                      "taskReferenceName": "get_test_group",
                      "inputParameters": {
                        "test_groups": "${find_test_group_by_base_url.output.response.body}",
                        "scriptExpression": "return $.test_groups[0]"
                      },
                      "type": "LAMBDA",
                      "decisionCases": {},
                      "defaultCase": [],
                      "forkTasks": [],
                      "startDelay": 0,
                      "joinOn": [],
                      "optional": false,
                      "defaultExclusiveJoinTask": [],
                      "asyncComplete": false,
                      "loopOver": []
                    }
                  ],
                  "forkTasks": [],
                  "startDelay": 0,
                  "joinOn": [],
                  "optional": false,
                  "defaultExclusiveJoinTask": [],
                  "asyncComplete": false,
                  "loopOver": []
                }
              ]
            },
            "defaultCase": [
              {
                "name": "get_test_group_by_address_lambda",
                "taskReferenceName": "get_test_group",
                "inputParameters": {
                  "test_groups": "${find_test_group_by_address.output.response.body}",
                  "scriptExpression": "return $.test_groups[0]"
                },
                "type": "LAMBDA",
                "decisionCases": {},
                "defaultCase": [],
                "forkTasks": [],
                "startDelay": 0,
                "joinOn": [],
                "optional": false,
                "defaultExclusiveJoinTask": [],
                "asyncComplete": false,
                "loopOver": []
              }
            ],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [
        {
          "name": "get_test_group_by_name_lambda",
          "taskReferenceName": "get_test_group",
          "inputParameters": {
            "test_groups": "${find_test_group_by_name.output.response.body}",
            "scriptExpression": "return $.test_groups[0]"
          },
          "type": "LAMBDA",
          "decisionCases": {},
          "defaultCase": [],
          "forkTasks": [],
          "startDelay": 0,
          "joinOn": [],
          "optional": false,
          "defaultExclusiveJoinTask": [],
          "asyncComplete": false,
          "loopOver": []
        }
      ],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "check_if_test_group_has_ready_state_decision",
      "taskReferenceName": "check_if_test_group_has_ready_state",
      "inputParameters": {
        "state": "${get_test_group.output.result.state}"
      },
      "type": "DECISION",
      "caseExpression": "$.state !== 'READY'",
      "decisionCases": {
        "true": [
          {
            "name": "fail_test_no_vta_has_state_ready",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"VTA isn't in READY state\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "set_nid_resource_lock",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-policy:3200/api/v1/reservations",
            "method": "POST",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}",
            "body": {
              "criteria": {
                "nid": "${workflow.input.topology.neTo.name}"
              },
              "properties": {
                "workflowId": "${workflow.workflowId}"
              },
              "userName": "${workflow.input.security.username}"
            }
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "nid_resource_lock_decision_task",
      "taskReferenceName": "nid_resource_lock_decision",
      "inputParameters": {
        "statusCode": "${set_nid_resource_lock.output.response.statusCode}"
      },
      "type": "DECISION",
      "caseExpression": "$.statusCode == 400 ? 'REJECTED' : $.statusCode == null || $.statusCode > 400 ? 'ERROR' : 'OK'",
      "decisionCases": {
        "REJECTED": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"Another client is already using '${workflow.input.topology.neTo.name}' NID preventing this workflow from using it.\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"Unable to lock resources\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "set_eswitch_vta_resource_lock",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-policy:3200/api/v1/reservations",
            "method": "POST",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}",
            "body": {
              "criteria": {
                "eswitch": "${workflow.input.topology.neFrom.name}",
                "vta": "${get_test_group.output.result.id}"
              },
              "properties": {
                "workflowId": "${workflow.workflowId}",
                "cvlan": "${workflow.input.tests.eswitchTest.vlan}",
                "svlan": "${workflow.input.tests.eswitchTest.inner_vlan}",
                "aid": "${workflow.input.tests.eswitchTest.port}"
              },
              "userName": "${workflow.input.security.username}"
            }
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "vta_resource_lock_decision_task",
      "taskReferenceName": "vta_resource_lock_decision",
      "inputParameters": {
        "statusCode": "${set_eswitch_vta_resource_lock.output.response.statusCode}"
      },
      "type": "DECISION",
      "caseExpression": "$.statusCode == 400 ? 'REJECTED' : $.statusCode == null || $.statusCode > 400 ? 'ERROR' : 'OK'",
      "decisionCases": {
        "REJECTED": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"Another client is already using '${workflow.input.topology.neFrom.name}' and '${get_test_group.output.result.name}' preventing this workflow from using them.\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"Unable to lock resources\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "nid_testcases_decision_task",
      "taskReferenceName": "decide_nid_testcases",
      "inputParameters": {
        "model": "${workflow.input.topology.neTo.model}"
      },
      "type": "DECISION",
      "caseValueParam": "model",
      "decisionCases": {
        "7705": [
          {
            "name": "nid_testcases_lambda_task",
            "taskReferenceName": "nid_testcases",
            "inputParameters": {
              "scriptExpression": "return { initAccess: 'di_Alcatel_7705/Init_Access.fftc', releaseAccess: 'di_Alcatel_7705/Release_Access.fftc', setupLpbk: 'di_Alcatel_7705/Setup_Loopback.fftc', releaseLpbk: 'di_Alcatel_7705/Release_Loopback.fftc'}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "7210 SAS-M": [
          {
            "name": "nid_testcases_lambda_task",
            "taskReferenceName": "nid_testcases",
            "inputParameters": {
              "scriptExpression": "return { initAccess: 'di_Alcatel_7210/Init_Access.fftc', releaseAccess: 'di_Alcatel_7210/Release_Access.fftc', setupLpbk: 'di_Alcatel_7210/Setup_Loopback.fftc', releaseLpbk: 'di_Alcatel_7210/Release_Loopback.fftc'}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "7210 SAS-MXP": [
          {
            "name": "nid_testcases_lambda_task",
            "taskReferenceName": "nid_testcases",
            "inputParameters": {
              "scriptExpression": "return { initAccess: 'di_Alcatel_7210/Init_Access.fftc', releaseAccess: 'di_Alcatel_7210/Release_Access.fftc', setupLpbk: 'di_Alcatel_7210/Setup_Loopback.fftc', releaseLpbk: 'di_Alcatel_7210/Release_Loopback.fftc'}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "7210 SAS-K": [
          {
            "name": "nid_testcases_lambda_task",
            "taskReferenceName": "nid_testcases",
            "inputParameters": {
              "scriptExpression": "return { initAccess: 'di_Alcatel_7210/Init_Access.fftc', releaseAccess: 'di_Alcatel_7210/Release_Access.fftc', setupLpbk: 'di_Alcatel_7210/Setup_Loopback.fftc', releaseLpbk: 'di_Alcatel_7210/Release_Loopback.fftc'}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_testcases_decision_task",
      "taskReferenceName": "decide_eswitch_testcases",
      "inputParameters": {
        "vendor": "${workflow.input.topology.neFrom.vendor}"
      },
      "type": "DECISION",
      "caseValueParam": "vendor",
      "decisionCases": {
        "NOKIA": [
          {
            "name": "eswitch_testcases_lambda_task",
            "taskReferenceName": "eswitch_testcases",
            "inputParameters": {
              "model": "${workflow.input.topology.neFrom.model}",
              "scriptExpression": "if ($.model === '7450' || $.model === '7750' || $.model === '7950') {return { initAccess: 'di_Alcatel_7X50/Init_Access.fftc', releaseAccess: 'di_Alcatel_7X50/Release_Access.fftc', setupXConnect: 'di_Alcatel_7X50/Setup_Xconnect.fftc', releaseXConnect: 'di_Alcatel_7X50/Release_Xconnect.fftc'}}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "evaluate_network_direction_lambda_task",
      "taskReferenceName": "evaluate_network_direction",
      "inputParameters": {
        "networkElements": "${workflow.input.topology.service.segments[0].networkElements}",
        "neFromName": "${workflow.input.topology.neFrom.name}",
        "neToName": "${workflow.input.topology.neTo.name}",
        "networkTypeCode": 30,
        "scriptExpression": "if ( Array.prototype.filter.apply($.networkElements, [function(ne) {return ne.name === $.neFromName || ne.name === $.neToName || ne.typeCode === $.networkTypeCode;}]).map(function(ne) {return ne.typeCode}).join('-').indexOf('-' + $.networkTypeCode + '-') != -1 ) {return 'Network';} else {return 'Local';}"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_init_access_sub_workflow",
      "taskReferenceName": "eswitch_init_access",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "vlan": "${workflow.input.tests.eswitchTest.vlan}",
            "inner_vlan": "${workflow.input.tests.eswitchTest.inner_vlan}",
            "service_id": "${workflow.input.tests.eswitchTest.service_id}",
            "interrupt_oper_down": "${workflow.input.tests.eswitchTest.interrupt_oper_down}",
            "port": "${workflow.input.tests.eswitchTest.port}",
            "local_interface": "${workflow.input.topology.neFrom.testLink.northBoundTap}",
            "ipAddress": "${workflow.input.topology.neFrom.commLink.addr}",
            "userName": "${workflow.input.topology.neFrom.userId}",
            "password": "${workflow.input.topology.neFrom.password}",
            "vendor": "${workflow.input.topology.neFrom.vendor}",
            "model": "${workflow.input.topology.neFrom.model}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${eswitch_testcases.output.result.initAccess}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_init_access_check_failure_decision",
      "taskReferenceName": "eswitch_init_access_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${eswitch_init_access.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "eswitch_init_access_error_message_lambda_task",
            "taskReferenceName": "eswitch_init_access_error_message",
            "inputParameters": {
              "reason": "${eswitch_init_access.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${eswitch_init_access_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_eswitch_ia_result_lambda_task",
      "taskReferenceName": "process_eswitch_ia_result",
      "inputParameters": {
        "state": "${eswitch_init_access.output.state}",
        "resultStr": "${eswitch_init_access.output.resultStr}",
        "result": "${eswitch_init_access.output.result}",
        "passMessage": "Test case Init_Access has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.eswitchInitAccessDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.eswitchInitAccessResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.eswitchInitAccessResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_eswitch_init_access",
      "taskReferenceName": "publish_eswitch_ia_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_eswitch_ia_result.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_init_access_result_decision",
      "taskReferenceName": "eswitch_init_access_check_result",
      "inputParameters": {
        "status": "${eswitch_init_access.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${eswitch_init_access.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "loopback_nid_init_access_sub_workflow",
      "taskReferenceName": "loopback_nid_init_access",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "vlan": "${workflow.input.tests.lpbkTest.vlan}",
            "inner_vlan": "${workflow.input.tests.lpbkTest.inner_vlan}",
            "service_id": "${workflow.input.tests.lpbkTest.service_id}",
            "port": "${workflow.input.tests.lpbkTest.port}",
            "ipAddress": "${workflow.input.tests.lpbkTest.addr}",
            "userName": "${workflow.input.topology.neTo.userId}",
            "password": "${workflow.input.topology.neTo.password}",
            "vendor": "${workflow.input.topology.neTo.vendor}",
            "model": "${workflow.input.topology.neTo.model}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${nid_testcases.output.result.initAccess}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "loopback_nid_init_access_check_failure_decision",
      "taskReferenceName": "loopback_nid_init_access_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${loopback_nid_init_access.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "loopback_nid_init_access_error_message_lambda_task",
            "taskReferenceName": "loopback_nid_init_access_error_message",
            "inputParameters": {
              "reason": "${loopback_nid_init_access.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${loopback_nid_init_access_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_loopback_nid_ia_result_lambda",
      "taskReferenceName": "process_loopback_nid_ia_result",
      "inputParameters": {
        "state": "${loopback_nid_init_access.output.state}",
        "resultStr": "${loopback_nid_init_access.output.resultStr}",
        "result": "${loopback_nid_init_access.output.result}",
        "passMessage": "Test case Init_Access has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.loopbackInitAccessDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.loopbackInitAccessResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.loopbackInitAccessResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_loopback_nid_init_access",
      "taskReferenceName": "publish_loopback_nid_ia_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_loopback_nid_ia_result.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "loopback_nid_init_access_decision",
      "taskReferenceName": "loopback_init_access_check_result",
      "inputParameters": {
        "status": "${loopback_nid_init_access.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${loopback_nid_init_access.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "evaluate_nid_init_access_lambda_task",
      "taskReferenceName": "evaluate_nid_init_access_output",
      "inputParameters": {
        "result": "${loopback_nid_init_access.output.result}",
        "scriptExpression": "return {mac_address: $.result['MAC Address']}"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "setup_loopback_sub_workflow",
      "taskReferenceName": "setup_loopback",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "ipAddress": "${workflow.input.tests.lpbkTest.addr}",
            "port_id": "${workflow.input.tests.lpbkTest.port_id}",
            "service_id": "${workflow.input.tests.lpbkTest.service_id}",
            "service_type": "${loopback_nid_init_access.output.result.Service_Type}",
            "src_mac": "${workflow.input.tests.lpbkTest.source_mac}",
            "sap": "${workflow.input.tests.lpbkTest.sap}",
            "userName": "${workflow.input.topology.neTo.userId}",
            "password": "${workflow.input.topology.neTo.password}",
            "vendor": "${workflow.input.topology.neTo.vendor}",
            "model": "${workflow.input.topology.neTo.model}",
            "vlan": "${workflow.input.tests.lpbkTest.vlan}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${nid_testcases.output.result.setupLpbk}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "setup_loopback_check_failure_decision",
      "taskReferenceName": "setup_loopback_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${setup_loopback.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "setup_loopback_error_message_lambda_task",
            "taskReferenceName": "setup_loopback_error_message",
            "inputParameters": {
              "reason": "${setup_loopback.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${setup_loopback_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_setup_loopback_result_lambda",
      "taskReferenceName": "process_setup_loopback_result",
      "inputParameters": {
        "state": "${setup_loopback.output.state}",
        "resultStr": "${setup_loopback.output.resultStr}",
        "result": "${setup_loopback.output.result}",
        "passMessage": "Test case Setup_Loopback has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.setupLoopbackDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.setupLoopbackResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.setupLoopbackResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_setup_loopback",
      "taskReferenceName": "publish_loopback_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_setup_loopback_result.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "setup_loopback_decision",
      "taskReferenceName": "setup_loopback_check_result",
      "inputParameters": {
        "status": "${setup_loopback.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${setup_loopback.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_setup_xconnect_sub_workflow",
      "taskReferenceName": "eswitch_setup_xconnect",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "vlan": "${workflow.input.tests.eswitchTest.vlan}",
            "inner_vlan": "${workflow.input.tests.eswitchTest.inner_vlan}",
            "service_id": "${workflow.input.tests.eswitchTest.service_id}",
            "service_type": "${eswitch_init_access.output.result.Service_Type}",
            "vc_switching": "${eswitch_init_access.output.result.VC_Switching}",
            "passive_enabled": "${eswitch_init_access.output.result.passive_enabled}",
            "customer_id": "${eswitch_init_access.output.result.Customer_ID}",
            "port": "${workflow.input.tests.eswitchTest.port}",
            "local_interface": "${workflow.input.topology.neFrom.testLink.northBoundTap}",
            "ipAddress": "${workflow.input.topology.neFrom.commLink.addr}",
            "userName": "${workflow.input.topology.neFrom.userId}",
            "password": "${workflow.input.topology.neFrom.password}",
            "vendor": "${workflow.input.topology.neFrom.vendor}",
            "model": "${workflow.input.topology.neFrom.model}",
            "direction": "${workflow.input.tests.eswitchTest.direction}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${eswitch_testcases.output.result.setupXConnect}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_setup_xconnect_check_failure_decision",
      "taskReferenceName": "eswitch_setup_xconnect_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${eswitch_setup_xconnect.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "eswitch_setup_xconnect_error_message_lambda_task",
            "taskReferenceName": "eswitch_setup_xconnect_error_message",
            "inputParameters": {
              "reason": "${eswitch_setup_xconnect.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${eswitch_setup_xconnect_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_eswitch_setup_xconnect_lambda_task",
      "taskReferenceName": "process_eswitch_setup_xconnect_result",
      "inputParameters": {
        "resultStr": "${eswitch_setup_xconnect.output.resultStr}",
        "result": "${eswitch_setup_xconnect.output.result}",
        "passMessage": "Test case Setup_Xconnect has passed.",
        "state": "${eswitch_init_access.output.state}",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.eswitchSetupXConnectDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.eswitchSetupXConnectResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.eswitchSetupXConnectResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_eswitch_setup_xconnect",
      "taskReferenceName": "publish_eswitch_setup_xconnect_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_eswitch_setup_xconnect_result.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eswitch_setup_xconnect_result_decision_task",
      "taskReferenceName": "eswitch_setup_xconnect_check_result",
      "inputParameters": {
        "status": "${eswitch_setup_xconnect.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${eswitch_setup_xconnect.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "evaluate_setup_xconnect_lambda_task",
      "taskReferenceName": "evaluate_setup_xconnect_output",
      "inputParameters": {
        "result": "${eswitch_setup_xconnect.output.result}",
        "scriptExpression": "return {service_unit_id: $.result['Service Unit ID'], neighbor: $.result['Neighbor'], xconn_group_name: $.result['Group Name'], p2p_xconn_name: $.result['P2P Name'], network_interface: $.result['Network Interface']}"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "determine_vta_mac_lambda_task",
      "taskReferenceName": "determine_vta_mac",
      "inputParameters": {
        "vta": "${get_test_group.output.result}",
        "scriptExpression": "var interfaces = Array.prototype.filter.apply($.vta.interfaces || [], [function(i) {\n    return i.name && i.name === \"ens4\";\n}]);\nreturn interfaces.length > 0 ? interfaces[0].macAddress : null;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "determine_target_mac_lambda_task",
      "taskReferenceName": "determine_target_mac",
      "inputParameters": {
        "nid_mac": "${evaluate_nid_init_access_output.output.result.mac_address}",
        "scriptExpression": "if ($.nid_mac) {\n    return $.nid_mac.replace(/-/g, ':');\n}\n// some drivers do not return device MAC, we can use any MAC in this case\nreturn \"0025ba0e0187\";"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task",
      "taskReferenceName": "build_rfc2544_parameters",
      "inputParameters": {
        "parameters": {
          "virtual-link": {
            "aid": 2,
            "root-requirement": {
              "outer-vlan": {
                "vlan-id": "${workflow.input.tests.eswitchTest.vlan}",
                "priority": "${workflow.input.tests.rfc_2544.stream.vlan_priority.outer}",
                "cir": 1
              }
            }
          },
          "target": {
            "type": "${workflow.input.tests.rfc_2544.stream.target.type}",
            "mac-address": "${determine_target_mac.output.result}"
          },
          "qos": 0,
          "rate": "${workflow.input.tests.rfc_2544.stream.rate}",
          "rate-type": "${workflow.input.tests.rfc_2544.stream.rate_type}",
          "stage-duration": "${workflow.input.tests.rfc_2544.stream.stage_duration}",
          "trial-attempts": "${workflow.input.tests.rfc_2544.stream.stage_attempts}",
          "max-test-duration": "${workflow.input.tests.rfc_2544.stream.max_test_duration}",
          "ethernet-protocol-type": "${workflow.input.tests.rfc_2544.stream.ethernet_frame_settings.protocol_type}",
          "eth-type": "${workflow.input.tests.rfc_2544.stream.ethernet_frame_settings.ethernet_type}",
          "frame-loss-threshold": "${workflow.input.tests.rfc_2544.stream.loss_threshold}",
          "overhead-bytes": "${workflow.input.tests.rfc_2544.stream.obabn}",
          "algorithm": "${workflow.input.tests.rfc_2544.stream.algorithm}",
          "frame-sizes": [
            "${workflow.input.tests.rfc_2544.stream.fs}"
          ]
        },
        "queryExpression": "walk( if type == \"object\" then with_entries(select(.value != null)) else . end)"
      },
      "type": "JSON_JQ_TRANSFORM",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "create_rfc2544_test_session",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-testcontroller:3030/api/v1/test-sessions",
            "method": "POST",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}",
            "body": {
              "serviceName": "${workflow.input.topology.service.name}",
              "testGroupId": "${get_test_group.output.result.id}",
              "measurementMethod": "vta-rfc2544:test/rfc2544",
              "userName": "${workflow.input.security.username}"
            }
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "session_state_listener",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/listen",
          "method": "POST",
          "body": {
            "workflowId": "${workflow.workflowId}",
            "waitTask": "wait_for_kafka_events",
            "topic": "tc-session-state",
            "filters": [
              {
                "sessionId": "${create_rfc2544_test_session.output.response.body}",
                "state": "COMPLETED"
              },
              {
                "sessionId": "${create_rfc2544_test_session.output.response.body}",
                "state": "ERROR"
              },
              {
                "sessionId": "${create_rfc2544_test_session.output.response.body}",
                "state": "UNAVAILABLE"
              }
            ],
            "timeoutMs": 86400000,
            "single": true
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "results_listener",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/listen",
          "method": "POST",
          "body": {
            "workflowId": "${workflow.workflowId}",
            "waitTask": "wait_for_kafka_events",
            "topic": "tram-session-result",
            "filters": [
              {
                "sessionId": "${create_rfc2544_test_session.output.response.body}"
              }
            ],
            "timeoutMs": 86400000
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "execute_rfc2544_test",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 15000,
          "connectionTimeOut": 15000,
          "body": {
            "uri": "http://us-testcontroller:3030/api/v1/test-sessions/${create_rfc2544_test_session.output.response.body}/execution",
            "method": "POST",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}",
            "body": "${build_rfc2544_parameters.output.result.parameters}"
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "do_while_day_timeout",
      "taskReferenceName": "handle_kafka_events_rfc2544",
      "inputParameters": {},
      "type": "DO_WHILE",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopCondition": "$.wait_for_kafka_events.topic !== 'tc-session-state'",
      "loopOver": [
        {
          "name": "wait_for_kafka_events_task",
          "taskReferenceName": "wait_for_kafka_events",
          "inputParameters": {},
          "type": "WAIT",
          "decisionCases": {},
          "defaultCase": [],
          "forkTasks": [],
          "startDelay": 0,
          "joinOn": [],
          "optional": false,
          "defaultExclusiveJoinTask": [],
          "asyncComplete": false,
          "loopOver": []
        },
        {
          "name": "handle_kafka_event_decision",
          "taskReferenceName": "handle_kafka_event",
          "inputParameters": {
            "topic": "${wait_for_kafka_events_rfc2544.output.topic}"
          },
          "type": "DECISION",
          "caseValueParam": "topic",
          "decisionCases": {
            "tram-session-result": [
              {
                "name": "generic_task_no_retry",
                "taskReferenceName": "get_tram_result",
                "inputParameters": {
                  "http_request": {
                    "uri": "http://conductor-helper:8085/http",
                    "method": "POST",
                    "readTimeOut": 30000,
                    "connectionTimeOut": 30000,
                    "body": {
                      "uri": "http://us-tram:3040/api/v1/results/${create_rfc2544_test_session.output.response.body}/${wait_for_kafka_events.output.message.resultId}",
                      "method": "GET",
                      "accessToken": "${workflow.input.security.access_token}",
                      "refreshToken": "${workflow.input.security.refresh_token}"
                    }
                  }
                },
                "type": "HTTP",
                "decisionCases": {},
                "defaultCase": [],
                "forkTasks": [],
                "startDelay": 0,
                "joinOn": [],
                "optional": false,
                "defaultExclusiveJoinTask": [],
                "asyncComplete": false,
                "loopOver": []
              },
              {
                "name": "build_intermediate_result_lambda_task",
                "taskReferenceName": "build_intermediate_result",
                "inputParameters": {
                  "result": "${get_tram_result.output.response.body}",
                  "prefix": "rfc2544Result.",
                  "scriptExpression": "var intermediateResult = {};\ntry {\n    var parsedResult = JSON.parse($.result.result);\n    for (var key in parsedResult) {\n        intermediateResult[$.prefix + key] = parsedResult[key];\n    }\n} catch (e) {}\nreturn JSON.stringify(intermediateResult);"
                },
                "type": "LAMBDA",
                "decisionCases": {},
                "defaultCase": [],
                "forkTasks": [],
                "startDelay": 0,
                "joinOn": [],
                "optional": false,
                "defaultExclusiveJoinTask": [],
                "asyncComplete": false,
                "loopOver": []
              },
              {
                "name": "call_kafka",
                "taskReferenceName": "publish_intermediate_result_to_kafka",
                "inputParameters": {
                  "kafka_request": {
                    "topic": "workflow-result",
                    "value": {
                      "type": "workflow-result",
                      "resultId": "${workflow.input.resultId}",
                      "message": "${build_intermediate_result.output.result}"
                    },
                    "bootStrapServers": "kafka:9092",
                    "headers": {
                      "x-Auth": "Auth-key"
                    },
                    "key": "123",
                    "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
                  }
                },
                "type": "KAFKA_PUBLISH",
                "decisionCases": {},
                "defaultCase": [],
                "forkTasks": [],
                "startDelay": 0,
                "joinOn": [],
                "optional": false,
                "defaultExclusiveJoinTask": [],
                "asyncComplete": false,
                "loopOver": []
              }
            ]
          },
          "defaultCase": [],
          "forkTasks": [],
          "startDelay": 0,
          "joinOn": [],
          "optional": false,
          "defaultExclusiveJoinTask": [],
          "asyncComplete": false,
          "loopOver": []
        }
      ]
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "stop_results_listener",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/listen/${results_listener.output.response.body.listenerId}",
          "method": "DELETE"
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "get_rfc2544_results",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-tram:3040/api/v1/results/${create_rfc2544_test_session.output.response.body}",
            "method": "GET",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}"
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "eval_rfc2544_state_lambda_task",
      "taskReferenceName": "eval_rfc2544_state",
      "inputParameters": {
        "kafkaEventsOutput": "${handle_kafka_events_rfc2544.output}",
        "scriptExpression": "var lastIteration = parseInt($.kafkaEventsOutput.iteration);\nif (lastIteration >= 1) {\n    var lastTask = $.kafkaEventsOutput[$.kafkaEventsOutput.iteration.toString()].wait_for_kafka_events;\n    if (lastTask && lastTask.topic === \"tc-session-state\" && lastTask.message) {\n        return lastTask.message.state;\n    }\n}\nreturn \"TIMED_OUT\";"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "rfc2544_check_state_decision",
      "taskReferenceName": "rfc2544_check_state",
      "inputParameters": {
        "status": "${eval_rfc2544_state.output.result}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "process_rfc2544_error_result_lambda",
            "taskReferenceName": "process_rfc2544_error_result",
            "inputParameters": {
              "results": "${get_rfc2544_results.output.response.body}",
              "scriptExpression": "if ($.results && $.results.length) {\n  var lastResult = $.results[$.results.length - 1];\n  return {output: JSON.stringify({errorMessage: lastResult.state.errMsg})}\n}"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${process_rfc2544_error_result.output.result}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "UNAVAILABLE": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"VTA test session is UNAVAILABLE\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ],
        "TIMED_OUT": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"Workflow timed out. Kafka event with a session state was not received.\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_rfc2544_result_lambda",
      "taskReferenceName": "process_rfc2544_result",
      "inputParameters": {
        "results": "${get_rfc2544_results.output.response.body}",
        "scriptExpression": "var overallResult = {};\nvar overallPass = true;\n\nfor (var i = 0; i < $.results.length; i++) {\n    var result = $.results[i].result ? JSON.parse($.results[i].result) : {};\n\n    if (result['cir-configuration-test'] && result['cir-configuration-test'].steps) {\n        var cirPass = Array.prototype.every.apply(result['cir-configuration-test'].steps, [function (i) {\n            return i['pass-fail'] && i['pass-fail'].match(/pass/i);\n        }]);\n        result['cir-configuration-test'].result = cirPass ? 'Pass' : 'Fail';\n        overallPass = overallPass && cirPass;\n        overallResult['cir-configuration-test'] = result['cir-configuration-test'];\n    }\n    if (result['eir-configuration-test']) {\n        var eirPass = result['eir-configuration-test']['pass-fail'] && result['eir-configuration-test']['pass-fail'].match(/pass/i);\n        result['eir-configuration-test'].result = eirPass ? 'Pass' : 'Fail';\n        overallPass = overallPass && eirPass;\n        overallResult['eir-configuration-test'] = result['eir-configuration-test'];\n    }\n    if (result['traffic-policing-test']) {\n        var policingPass = result['traffic-policing-test']['pass-fail'] && result['traffic-policing-test']['pass-fail'].match(/pass/i);\n        result['traffic-policing-test'].result = policingPass ? 'Pass' : 'Fail';\n        overallPass = overallPass && policingPass;\n        overallResult['traffic-policing-test'] = result['traffic-policing-test'];\n    }\n    if (result['cbs-configuration-test']) {\n        var cbsPass = result['cbs-configuration-test']['pass-fail'] && result['cbs-configuration-test']['pass-fail'].match(/pass/i);\n        result['cbs-configuration-test'].result = cbsPass ? 'Pass' : 'Fail';\n        overallPass = overallPass && cbsPass;\n        overallResult['cbs-configuration-test'] = result['cbs-configuration-test'];\n    }\n    if (result['service-performance-test'] && result['service-performance-test'].streams) {\n        var performancePass = Array.prototype.every.apply(result['service-performance-test'].streams, [function (i) {\n            return i['pass-fail'] && i['pass-fail'].match(/pass/i);\n        }]);\n        result['service-performance-test'].result = performancePass ? 'Pass' : 'Fail';\n        overallResult['service-performance-test'] = result['service-performance-test'];\n        overallPass = overallPass && performancePass;\n    }\n}\n\noverallResult.result = overallPass ? 'Pass' : 'Fail';\nreturn JSON.stringify({rfc2544Result: overallResult.result, resultData: JSON.parse($.results[0].result)});"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_rfc2544",
      "taskReferenceName": "publish_rfc2544_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_rfc2544_result.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_xconnect_sub_workflow",
      "taskReferenceName": "release_eswitch_xconnect",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "vlan": "${workflow.input.tests.eswitchTest.vlan}",
            "inner_vlan": "${workflow.input.tests.eswitchTest.inner_vlan}",
            "port": "${workflow.input.tests.eswitchTest.port}",
            "service_id": "${workflow.input.tests.eswitchTest.service_id}",
            "service_type": "${eswitch_init_access.output.result.Service_Type}",
            "customer_id": "${eswitch_init_access.output.result.Customer_ID}",
            "local_interface": "${workflow.input.topology.neFrom.testLink.northBoundTap}",
            "ipAddress": "${workflow.input.topology.neFrom.commLink.addr}",
            "userName": "${workflow.input.topology.neFrom.userId}",
            "password": "${workflow.input.topology.neFrom.password}",
            "vendor": "${workflow.input.topology.neFrom.vendor}",
            "model": "${workflow.input.topology.neFrom.model}",
            "service_unit_id": "${evaluate_setup_xconnect_output.output.result.service_unit_id}",
            "neighbor": "${evaluate_setup_xconnect_output.output.result.neighbor}",
            "xconn_group_name": "${evaluate_setup_xconnect_output.output.result.xconn_group_name}",
            "p2p_xconn_name": "${evaluate_setup_xconnect_output.output.result.p2p_xconn_name}",
            "network_interface": "${evaluate_setup_xconnect_output.output.result.network_interface}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${eswitch_testcases.output.result.releaseXConnect}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_xconnect_check_failure_decision",
      "taskReferenceName": "release_eswitch_xconnect_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${release_eswitch_xconnect.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "release_eswitch_xconnect_error_message_lambda_task",
            "taskReferenceName": "release_eswitch_xconnect_error_message",
            "inputParameters": {
              "reason": "${release_eswitch_xconnect.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${release_eswitch_xconnect_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_release_eswitch_xconnect_lambda_task",
      "taskReferenceName": "process_release_eswitch_xconnect",
      "inputParameters": {
        "resultStr": "${release_eswitch_xconnect.output.resultStr}",
        "result": "${release_eswitch_xconnect.output.result}",
        "state": "${release_eswitch_xconnect.output.state}",
        "passMessage": "Test case Release_Xconnect has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.releaseXConnectDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.releaseXConnectResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.releaseXConnectResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_release_eswitch_xconnect",
      "taskReferenceName": "publish_release_xconnect_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_release_eswitch_xconnect.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_xconnect_decision",
      "taskReferenceName": "release_eswitch_xconnect_check_result",
      "inputParameters": {
        "status": "${release_eswitch_xconnect.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${release_eswitch_xconnect.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_loopback_sub_workflow",
      "taskReferenceName": "release_nid_loopback",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "ipAddress": "${workflow.input.tests.lpbkTest.addr}",
            "port_id": "${workflow.input.tests.lpbkTest.port_id}",
            "service_id": "${workflow.input.tests.lpbkTest.service_id}",
            "service_type": "${loopback_nid_init_access.output.result.Service_Type}",
            "src_mac": "${workflow.input.tests.lpbkTest.source_mac}",
            "sap": "${workflow.input.tests.lpbkTest.sap}",
            "userName": "${workflow.input.topology.neTo.userId}",
            "password": "${workflow.input.topology.neTo.password}",
            "vendor": "${workflow.input.topology.neTo.vendor}",
            "model": "${workflow.input.topology.neTo.model}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${nid_testcases.output.result.releaseLpbk}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_loopback_check_failure_decision",
      "taskReferenceName": "release_nid_loopback_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${release_nid_loopback.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "release_nid_loopback_error_message_lambda_task",
            "taskReferenceName": "release_nid_loopback_error_message",
            "inputParameters": {
              "reason": "${release_nid_loopback.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${release_nid_loopback_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_release_nid_loopback_lambda_task",
      "taskReferenceName": "process_release_nid_loopback",
      "inputParameters": {
        "resultStr": "${release_nid_loopback.output.resultStr}",
        "result": "${release_nid_loopback.output.result}",
        "state": "${release_nid_loopback.output.state}",
        "passMessage": "Test case Release_Loopback has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.releaseLoopbackDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.releaseLoopbackResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.releaseLoopbackResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_release_nid_loopback",
      "taskReferenceName": "publish_release_nid_loopback_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_release_nid_loopback.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_loopback_decision",
      "taskReferenceName": "release_nid_loopback_check_result",
      "inputParameters": {
        "status": "${release_nid_loopback.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${release_nid_loopback.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_access_sub_workflow",
      "taskReferenceName": "release_nid_access",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "ipAddress": "${workflow.input.tests.lpbkTest.addr}",
            "port": "${workflow.input.topology.neTo.aid}",
            "port_id": "${workflow.input.tests.lpbkTest.port_id}",
            "service_id": "${workflow.input.tests.lpbkTest.service_id}",
            "service_type": "${loopback_nid_init_access.output.result.Service_Type}",
            "src_mac": "${workflow.input.tests.lpbkTest.source_mac}",
            "sap": "${workflow.input.tests.lpbkTest.sap}",
            "userName": "${workflow.input.topology.neTo.userId}",
            "password": "${workflow.input.topology.neTo.password}",
            "vendor": "${workflow.input.topology.neTo.vendor}",
            "model": "${workflow.input.topology.neTo.model}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${nid_testcases.output.result.releaseAccess}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_access_check_failure_decision",
      "taskReferenceName": "release_nid_access_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${release_nid_access.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "release_nid_access_error_message_lambda_task",
            "taskReferenceName": "release_nid_access_error_message",
            "inputParameters": {
              "reason": "${release_nid_access.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${release_nid_access_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_release_nid_access_lambda_task",
      "taskReferenceName": "process_release_nid_access",
      "inputParameters": {
        "resultStr": "${release_nid_access.output.resultStr}",
        "result": "${release_nid_access.output.result}",
        "state": "${release_nid_access.output.state}",
        "passMessage": "Test case Release_Access has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.releaseNidAccessDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.releaseNidAccessResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.releaseNidAccessResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_release_nid_access",
      "taskReferenceName": "publish_release_nid_access_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_release_nid_access.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_nid_access_decision",
      "taskReferenceName": "release_nid_access_check_result",
      "inputParameters": {
        "status": "${release_nid_access.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${release_nid_access.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_access_sub_workflow",
      "taskReferenceName": "release_eswitch_access",
      "inputParameters": {
        "security": "${workflow.input.security}",
        "test": {
          "parameters": {
            "ipAddress": "${workflow.input.topology.neFrom.commLink.addr}",
            "vendor": "${workflow.input.topology.neFrom.vendor}",
            "model": "${workflow.input.topology.neFrom.model}",
            "service_id": "${workflow.input.tests.eswitchTest.service_id}",
            "userName": "${workflow.input.topology.neFrom.userId}",
            "password": "${workflow.input.topology.neFrom.password}"
          },
          "ndoGroup": "${workflow.input.ndo_group}",
          "name": "${eswitch_testcases.output.result.releaseAccess}"
        }
      },
      "type": "SUB_WORKFLOW",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "subWorkflowParam": {
        "name": "run_ndo_service_test",
        "version": 1,
        "taskToDomain": {
          "*": "mydomain"
        }
      },
      "joinOn": [],
      "optional": true,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_access_check_failure_decision",
      "taskReferenceName": "release_eswitch_access_check_failure",
      "inputParameters": {
        "reasonForIncompletion": "${release_eswitch_access.reasonForIncompletion}"
      },
      "type": "DECISION",
      "caseExpression": "$.reasonForIncompletion != null && $.reasonForIncompletion.indexOf(\"Workflow is FAILED by TERMINATE task\") === -1",
      "decisionCases": {
        "true": [
          {
            "name": "release_eswitch_access_error_message_lambda_task",
            "taskReferenceName": "release_eswitch_access_error_message",
            "inputParameters": {
              "reason": "${release_eswitch_access.reasonForIncompletion}",
              "scriptExpression": "var messageMatch = $.reason.match(/message=(.+),/);\nif (messageMatch && messageMatch.length > 1) {\n    return messageMatch[1];\n}\nreturn $.reason;\n"
            },
            "type": "LAMBDA",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          },
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "{\"errorMessage\": \"${release_eswitch_access_error_message.output.result}\"}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "process_release_eswitch_access_lambda_task",
      "taskReferenceName": "process_release_eswitch_access",
      "inputParameters": {
        "resultStr": "${release_eswitch_access.output.resultStr}",
        "result": "${release_eswitch_access.output.result}",
        "state": "${release_eswitch_access.output.state}",
        "passMessage": "Test case Release_Access has passed.",
        "scriptExpression": "var res = {};\nif ($.result != null) {\n  res.releaseEswitchAccessDetailedReport = $.result['detailed-report']\n}\nif ($.result.messages != null) {\n  res.releaseEswitchAccessResult = Array.prototype.indexOf.apply(JSON.parse($.resultStr).messages, [$.passMessage]) > 0 ? 'Pass' : 'Fail'\n} else {\n  res.releaseEswitchAccessResult = 'Fail'\n  res.errorMessage = $.state.errMsg\n}\nreturn res;"
      },
      "type": "LAMBDA",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "call_kafka_release_eswitch_access",
      "taskReferenceName": "publish_release_eswitch_access_result_to_kafka",
      "inputParameters": {
        "kafka_request": {
          "topic": "workflow-result",
          "value": {
            "type": "workflow-result",
            "resultId": "${workflow.input.resultId}",
            "message": "${process_release_eswitch_access.output.result}"
          },
          "bootStrapServers": "kafka:9092",
          "headers": {
            "x-Auth": "Auth-key"
          },
          "key": "123",
          "keySerializer": "org.apache.kafka.common.serialization.IntegerSerializer"
        }
      },
      "type": "KAFKA_PUBLISH",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "release_eswitch_access_decision",
      "taskReferenceName": "release_eswitch_access_check_result",
      "inputParameters": {
        "status": "${release_eswitch_access.output.state.stateCode}"
      },
      "type": "DECISION",
      "caseValueParam": "status",
      "decisionCases": {
        "ERROR": [
          {
            "name": "terminate",
            "taskReferenceName": "fail_test",
            "inputParameters": {
              "terminationStatus": "FAILED",
              "workflowOutput": "${release_eswitch_access.output.resultStr}"
            },
            "type": "TERMINATE",
            "decisionCases": {},
            "defaultCase": [],
            "forkTasks": [],
            "startDelay": 0,
            "joinOn": [],
            "optional": false,
            "defaultExclusiveJoinTask": [],
            "asyncComplete": false,
            "loopOver": []
          }
        ]
      },
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "remove_nid_reservation",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-policy:3200/api/v1/reservations/${set_nid_resource_lock.output.response.body.id}",
            "method": "DELETE",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}"
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    },
    {
      "name": "generic_task_no_retry",
      "taskReferenceName": "remove_eswitch_vta_reservation",
      "inputParameters": {
        "http_request": {
          "uri": "http://conductor-helper:8085/http",
          "method": "POST",
          "readTimeOut": 30000,
          "connectionTimeOut": 30000,
          "body": {
            "uri": "http://us-policy:3200/api/v1/reservations/${set_eswitch_vta_resource_lock.output.response.body.id}",
            "method": "DELETE",
            "accessToken": "${workflow.input.security.access_token}",
            "refreshToken": "${workflow.input.security.refresh_token}"
          }
        }
      },
      "type": "HTTP",
      "decisionCases": {},
      "defaultCase": [],
      "forkTasks": [],
      "startDelay": 0,
      "joinOn": [],
      "optional": false,
      "defaultExclusiveJoinTask": [],
      "asyncComplete": false,
      "loopOver": []
    }
  ],
  "inputParameters": [
    "{\"propertyPath\":\"ndo_group\",\"control\":\"ndo-group-selector\",\"order\":1,\"required\":true,\"hidden\":false,\"disabled\":false,\"label\":\"NDO Group\",\"type\":\"string\",\"default\":\"\",\"values\":[],\"valueType\":\"string\"}",
    "{\"propertyPath\":\"topology\",\"control\":\"serviceselector-points\",\"order\":2,\"required\":true,\"hidden\":false,\"disabled\":false,\"label\":\"Service Name\",\"type\":\"object\"}",
    "{\"propertyPath\":\"tests.eswitchTest.port\",\"defaultValuePath\":\"${topology.neFrom.aid}\",\"control\":\"textfield\",\"order\":4,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"ESwitch Port\",\"type\":\"string\",\"values\":[],\"valueType\":\"\"}",
    "{\"propertyPath\":\"tests.eswitchTest.vlan\",\"defaultValuePath\":\"${topology.neFrom.sVlan}\",\"control\":\"textfield\",\"order\":5,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"ESwitch VLAN\",\"type\":\"integer\",\"default\":\"\",\"values\":[],\"valueType\":\"\"}",
    "{\"propertyPath\":\"tests.eswitchTest.inner_vlan\",\"defaultValuePath\":\"${topology.neFrom.cVlan}\",\"control\":\"textfield\",\"order\":6,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"ESwitch Inner VLAN\",\"type\":\"integer\",\"values\":[],\"valueType\":\"\"}",
    "{\"propertyPath\":\"tests.eswitchTest.service_id\",\"defaultValuePath\":\"${topology.neFrom.service_id}\",\"control\":\"textfield\",\"order\":6,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"ESwitch Service ID\",\"type\":\"integer\",\"values\":[],\"valueType\":\"\",\"min\":1,\"max\":9999999999}",
    "{\"propertyPath\":\"tests.lpbkTest.addr\",\"defaultValuePath\":\"${topology.neTo.commLink.addr}\",\"control\":\"textfield\",\"order\":7,\"required\":true,\"hidden\":false,\"disabled\":false,\"label\":\"NID Address\",\"type\":\"string\",\"values\":[],\"valueType\":\"\",\"regex\":\"^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$\",\"regexError\":\"Must be a valid IPv4 address.\"}",
    "{\"propertyPath\":\"tests.lpbkTest.port\",\"defaultValuePath\":\"${topology.neTo.aid}\",\"control\":\"textfield\",\"order\":8,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"NID Port\",\"type\":\"string\",\"values\":[],\"valueType\":\"\"}",
    "{\"propertyPath\":\"tests.lpbkTest.vlan\",\"defaultValuePath\":\"${topology.neTo.sVlan}\",\"control\":\"textfield\",\"order\":9,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"NID VLAN\",\"type\":\"integer\",\"values\":[],\"valueType\":\"\",\"min\":0,\"max\":4092}",
    "{\"propertyPath\":\"tests.lpbkTest.inner_vlan\",\"defaultValuePath\":\"${topology.neTo.cVlan}\",\"control\":\"textfield\",\"order\":10,\"required\":false,\"hidden\":false,\"disabled\":false,\"label\":\"NID Inner VLAN\",\"type\":\"integer\",\"values\":[],\"valueType\":\"\",\"min\":0,\"max\":4092}",
    "{\"propertyPath\":\"tests.rfc_2544.stream\",\"label\":\"RFC 2544\",\"order\":11}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.target\",\"label\":\"Target\",\"order\":12}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.target.type\",\"control\":\"autocomplete\",\"order\":13,\"required\":false,\"label\":\"Type\",\"type\":\"string\",\"values\":[\"STD\",\"IPLPBK\",\"PHYLPBK\"],\"default\":\"STD\"}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.ethernet_frame_settings\",\"label\":\"Ethernet Frame Settings\",\"order\":14}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.ethernet_frame_settings.protocol_type\",\"control\":\"autocomplete\",\"order\":15,\"required\":false,\"label\":\"Protocol Type\",\"type\":\"string\",\"default\":\"ETHTYPE\",\"values\":[\"Y1731\",\"STD\",\"ETHTYPE\"],\"disabled\":true}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.ethernet_frame_settings.ethernet_type\",\"control\":\"textfield\",\"order\":16,\"required\":false,\"label\":\"Ethernet type\",\"type\":\"string\", \"default\":\"0600\"}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.vlan_priority\",\"label\":\"VLAN Priority\",\"order\":19}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.vlan_priority.outer\",\"control\":\"autocomplete\",\"order\":20,\"required\":false,\"label\":\"Outer\",\"type\":\"integer\",\"default\":0,\"values\":[0,1,2,3,4,5,6,7]}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.algorithm\",\"control\":\"autocomplete\",\"order\":21,\"required\":false,\"label\":\"Algorithm\",\"type\":\"string\",\"default\":\"standard\",\"values\":[\"standard\",\"binary\"]}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.rate\",\"control\":\"textfield\",\"order\":22,\"required\":false,\"label\":\"Rate (Mbps)\",\"type\":\"number\",\"default\":1}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.rate_type\",\"control\":\"autocomplete\",\"order\":23,\"required\":false,\"label\":\"Rate type\",\"type\":\"string\",\"default\":\"L1\",\"values\":\"L1\",\"L2\",\"L3\"]}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.stage_duration\",\"control\":\"textfield\",\"order\":24,\"required\":false,\"label\":\"Stage Duration (secs)\",\"type\":\"integer\",\"default\":15}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.stage_attempts\",\"control\":\"autocomplete\",\"order\":25,\"required\":false,\"label\":\"Stage Attempts\",\"type\":\"integer\",\"default\":1,\"values\":[1,2,3]}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.loss_threshold\",\"control\":\"textfield\",\"order\":26,\"required\":false,\"label\":\"Loss Threshold (%)\",\"type\":\"number\",\"default\":99.9}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.fs\",\"label\":\"Frame Size (Bytes)\",\"order\":27, \"control\":\"autocomplete\",\"required\":false,\"type\":\"integer\",\"default\":128,\"values\":[64, 128,256,512,768,1024,1280,1518,9600],}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.max_test_duration\",\"control\":\"textfield\",\"order\":29,\"required\":false,\"label\":\"Maximum Test Duration (mins)\",\"type\":\"integer\",\"default\":5}",
    "{\"propertyPath\":\"tests.rfc_2544.stream.obabn\",\"control\":\"textfield\",\"order\":30,\"required\":false,\"label\":\"Overhead Bytes Added By Network\",\"type\":\"integer\",\"default\":0}"
  ],
  "outputParameters": {
    "resultStr": "${process_rfc2544_result.output.result}",
    "errorResultStr": "${fail_test.output.output}",
    "schemas": [
      "{\"propertyPath\":\"messages\",\"colors\":[{\"value\":\"Test case Init_Access has failed.\",\"color\":\"red\"},{\"value\":\"Test case Setup_Loopback has failed.\",\"color\":\"red\"},{\"value\":\"Test case Setup_Xconnect has failed.\",\"color\":\"red\"},{\"value\":\"Test case Release_Xconnect has failed.\",\"color\":\"red\"},{\"value\":\"Test case Release_Loopback has failed.\",\"color\":\"red\"},{\"value\":\"Test case Release_Access has failed.\",\"color\":\"red\"}],\"order\":1,\"label\":\"Execution Messages\",\"type\":\"list\",\"hidden\":false}",
      "{\"propertyPath\":\"detailed-report\",\"order\":2,\"label\":\"Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"errorMessage\",\"order\":3,\"label\":\"Error Message\",\"type\":\"string\",\"hidden\":false}",
      "{\"propertyPath\":\"eswitchInitAccessResult\",\"order\":4,\"label\":\"E-Switch Init Access - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"eswitchInitAccessDetailedReport\",\"order\":5,\"label\":\"E-Switch Init Access - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"loopbackInitAccessResult\",\"order\":6,\"label\":\"Loopback NID Init Access - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"loopbackInitAccessDetailedReport\",\"order\":7,\"label\":\"Loopback NID Init Access - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"setupLoopbackResult\",\"order\":8,\"label\":\"Setup Loopback - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"setupLoopbackDetailedReport\",\"order\":9,\"label\":\"Setup Loopback - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"eswitchSetupXConnectResult\",\"order\":10,\"label\":\"E-Switch Setup X-Connect - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"eswitchSetupXConnectDetailedReport\",\"order\":11,\"label\":\"E-Switch Setup X-Connect - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"rfc2544Result\",\"order\":12,\"label\":\"RFC 2544 Test - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"resultData.l1-received-rate\",\"order\":13,\"label\":\"L1 Received Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.l2-overhead-rate\",\"order\":103,\"label\":\"L2 Overhead Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.frames-rcvd\",\"order\":103,\"label\":\"Number of test frames received:\",\"type\":\"integer\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.l2-received-rate\",\"order\":103,\"label\":\"L2 Received Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.latency\",\"order\":103,\"label\":\"Latency:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.frames-lost\",\"order\":103,\"label\":\"Frame Loss:\",\"type\":\"integer\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.l1-overhead-rate\",\"order\":103,\"label\":\"L1 Overhead Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.jitter\",\"order\":103,\"label\":\"Jitter:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.load\",\"order\":103,\"label\":\"Load:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.l1-adjusted-rate\",\"order\":103,\"label\":\"L1 Adjusted Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.frames-sent\",\"order\":103,\"label\":\"Frames Sent:\",\"type\":\"integer\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.frame-loss-rate\",\"order\":103,\"label\":\"Frame Loss Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"resultData.frame-rate\",\"order\":103,\"label\":\"Frame Rate:\",\"type\":\"number\",\"hidden\":false}",
      "{\"propertyPath\":\"releaseXConnectResult\",\"order\":101,\"label\":\"E-Switch Release X-Connect - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"releaseXConnectDetailedReport\",\"order\":102,\"label\":\"E-Switch Release X-Connect - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"releaseLoopbackResult\",\"order\":103,\"label\":\"Release Loopback - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"releaseLoopbackDetailedReport\",\"order\":104,\"label\":\"Release Loopback - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"releaseNidAccessResult\",\"order\":105,\"label\":\"Loopback NID Release Access - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"releaseNidAccessDetailedReport\",\"order\":106,\"label\":\"Loopback NID Release Access - Detailed Report\",\"type\":\"\",\"hidden\":false}",
      "{\"propertyPath\":\"releaseEswitchAccessResult\",\"order\":107,\"label\":\"E-Switch Release Access - Result\",\"type\":\"string\",\"colors\":[{\"value\":\"Fail\",\"color\":\"red\"},{\"value\":\"Pass\",\"color\":\"green\"}],\"hidden\":false}",
      "{\"propertyPath\":\"releaseEswitchAccessDetailedReport\",\"order\":108,\"label\":\"E-Switch Release Access - Detailed Report\",\"type\":\"\",\"hidden\":false}"
    ]
  },
  "failureWorkflow": "cleanup_denim_cox_probe_to_nokia_via_nokia",
  "schemaVersion": 2,
  "restartable": true,
  "workflowStatusListenerEnabled": false,
  "ownerEmail": "contact@spirent.com",
  "timeoutPolicy": "ALERT_ONLY",
  "timeoutSeconds": 0
}